import os
import io
import base64
import sqlite3
import secrets
import logging
from pathlib import Path
from functools import wraps

import torch
import torch.nn as nn
import torch.nn.functional as F
import torchvision.transforms as transforms
from PIL import Image

from flask import Flask, request, jsonify, session, send_file
from flask_cors import CORS
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from werkzeug.security import generate_password_hash, check_password_hash
from dotenv import load_dotenv

from pdf_report import generate_pdf_report

# -----------------------------
# Environment
# -----------------------------
env_path = Path(__file__).resolve().parent / ".env"
load_dotenv(dotenv_path=env_path, override=True)

SECRET_KEY = os.getenv("SECRET_KEY") or secrets.token_hex(16)

# -----------------------------
# App Setup
# -----------------------------
app = Flask(__name__)
app.secret_key = SECRET_KEY

CORS(
    app,
    supports_credentials=True,
    resources={r"/*": {"origins": "http://localhost:3000"}}
)

limiter = Limiter(
    app=app,
    key_func=get_remote_address,
    default_limits=["20 per minute"]
)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
logger.info(f"Using device: {device}")

# -----------------------------
# Database
# -----------------------------
DB_FILE = "brain_tumor.db"


def init_db():
    conn = sqlite3.connect(DB_FILE)
    c = conn.cursor()

    c.execute("""
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT UNIQUE,
            email TEXT UNIQUE,
            password TEXT,
            role TEXT DEFAULT 'user',
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    """)

    c.execute("""
        CREATE TABLE IF NOT EXISTS predictions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            prediction TEXT,
            confidence REAL,
            is_tumor BOOLEAN,
            image_data TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    """)

    conn.commit()
    conn.close()


init_db()


# -----------------------------
# Auth Decorators
# -----------------------------
def login_required(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        if "user_id" not in session:
            return jsonify({"error": "Not authenticated"}), 401
        return f(*args, **kwargs)

    return wrapper


# -----------------------------
# Auth Routes
# -----------------------------
@app.route("/register", methods=["POST"])
def register():
    data = request.json
    username = data.get("username")
    email = data.get("email")
    password = data.get("password")

    if not all([username, email, password]):
        return jsonify({"error": "Missing fields"}), 400

    conn = sqlite3.connect(DB_FILE)
    c = conn.cursor()

    c.execute("SELECT id FROM users WHERE username=? OR email=?", (username, email))
    if c.fetchone():
        conn.close()
        return jsonify({"error": "User exists"}), 400

    hashed = generate_password_hash(password)
    c.execute(
        "INSERT INTO users (username, email, password) VALUES (?, ?, ?)",
        (username, email, hashed)
    )
    conn.commit()

    user_id = c.lastrowid
    conn.close()

    session["user_id"] = user_id
    session["username"] = username
    session["role"] = "user"

    return jsonify({
        "user": {
            "id": user_id,
            "username": username,
            "role": "user"
        }
    })


@app.route("/login", methods=["POST"])
def login():
    data = request.json
    username = data.get("username")
    password = data.get("password")

    conn = sqlite3.connect(DB_FILE)
    c = conn.cursor()
    c.execute(
        "SELECT id, password, role FROM users WHERE username=?",
        (username,)
    )
    user = c.fetchone()
    conn.close()

    if not user or not check_password_hash(user[1], password):
        return jsonify({"error": "Invalid credentials"}), 401

    session["user_id"] = user[0]
    session["username"] = username
    session["role"] = user[2]

    return jsonify({
        "user": {
            "id": user[0],
            "username": username,
            "role": user[2]
        }
    })


@app.route("/me", methods=["GET"])
def me():
    if "user_id" not in session:
        return jsonify({"error": "Not authenticated"}), 401

    return jsonify({
        "user": {
            "id": session["user_id"],
            "username": session["username"],
            "role": session["role"]
        }
    })


@app.route("/logout", methods=["POST"])
def logout():
    session.clear()
    return jsonify({"message": "Logged out"})


@app.route("/history", methods=["GET"])
@login_required
def history():
    conn = sqlite3.connect(DB_FILE)
    c = conn.cursor()

    c.execute("""
        SELECT prediction, confidence, created_at
        FROM predictions
        WHERE user_id=?
        ORDER BY created_at DESC
    """, (session["user_id"],))

    rows = c.fetchall()
    conn.close()

    return jsonify({
        "predictions": [
            {
                "prediction": r[0],
                "confidence": round(r[1] * 100, 2),
                "created_at": r[2]
            } for r in rows
        ]
    })


# -----------------------------
# Model
# -----------------------------
class CNN_TUMOR(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv = nn.Sequential(
            nn.Conv2d(3, 32, 3, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(2),
            nn.Conv2d(32, 64, 3, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(2)
        )
        self.fc = nn.Sequential(
            nn.Flatten(),
            nn.Linear(64 * 56 * 56, 128),
            nn.ReLU(),
            nn.Linear(128, 4)
        )

    def forward(self, x):
        return F.log_softmax(self.fc(self.conv(x)), dim=1)


MODEL_PATH = "Brain_Tumor_model.pt"
class_names = ["glioma", "meningioma", "notumor", "pituitary"]

transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor()
])

# Load model - handle both full model and state_dict formats
try:
    # Try loading as state_dict first
    model = CNN_TUMOR()
    model.load_state_dict(torch.load(MODEL_PATH, map_location=device, weights_only=False))
    logger.info("Model loaded from state_dict")
except (TypeError, RuntimeError):
    # If that fails, it's the full model
    model = torch.load(MODEL_PATH, map_location=device, weights_only=False)
    logger.info("Model loaded as full model object")

model.to(device)
model.eval()


# -----------------------------
# Prediction
# -----------------------------
@app.route("/predict", methods=["POST"])
@login_required
def predict():
    if "image" not in request.files:
        return jsonify({"error": "No image"}), 400

    image_bytes = request.files["image"].read()
    image = Image.open(io.BytesIO(image_bytes)).convert("RGB")

    tensor = transform(image).unsqueeze(0).to(device)

    with torch.no_grad():
        output = model(tensor)
        probs = torch.exp(output)[0]
        conf, pred = torch.max(probs, 0)

    conn = sqlite3.connect(DB_FILE)
    c = conn.cursor()
    c.execute("""
        INSERT INTO predictions (user_id, prediction, confidence, is_tumor, image_data)
        VALUES (?, ?, ?, ?, ?)
    """, (
        session["user_id"],
        class_names[pred],
        float(conf),
        class_names[pred] != "notumor",
        base64.b64encode(image_bytes).decode()
    ))
    conn.commit()
    prediction_id = c.lastrowid
    conn.close()

    is_tumor = class_names[pred] != "notumor"

    return jsonify({
        "prediction_id": prediction_id,
        "prediction": class_names[pred],
        "confidence": round(float(conf) * 100, 2),
        "is_tumor": is_tumor,
        "probabilities": {
            class_names[i]: round(float(probs[i]) * 100, 2)
            for i in range(len(class_names))
        }
    })


def admin_required(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        if "user_id" not in session:
            return jsonify({"error": "Not authenticated"}), 401
        if session.get("role") != "superadmin":
            return jsonify({"error": "Admin access required"}), 403
        return f(*args, **kwargs)

    return wrapper


@app.route("/admin/stats", methods=["GET"])
@admin_required
def admin_stats():
    conn = sqlite3.connect(DB_FILE)
    c = conn.cursor()

    c.execute("SELECT COUNT(*) FROM users")
    total_users = c.fetchone()[0]

    c.execute("SELECT COUNT(*) FROM predictions")
    total_predictions = c.fetchone()[0]

    c.execute("SELECT COUNT(*) FROM predictions WHERE is_tumor=1")
    tumor_detections = c.fetchone()[0]

    rate = round((tumor_detections / total_predictions) * 100, 2) if total_predictions else 0

    c.execute("""
        SELECT prediction, COUNT(*)
        FROM predictions
        GROUP BY prediction
    """)
    predictions_by_type = dict(c.fetchall())

    c.execute("""
        SELECT DATE(created_at), COUNT(*)
        FROM predictions
        WHERE created_at >= DATE('now', '-7 days')
        GROUP BY DATE(created_at)
    """)
    recent_activity = [
        {"date": row[0], "count": row[1]}
        for row in c.fetchall()
    ]

    conn.close()

    return jsonify({
        "total_users": total_users,
        "total_predictions": total_predictions,
        "tumor_detections": tumor_detections,
        "tumor_detection_rate": rate,
        "predictions_by_type": predictions_by_type,
        "recent_activity": recent_activity
    })


@app.route("/admin/users", methods=["GET"])
@admin_required
def admin_users():
    conn = sqlite3.connect(DB_FILE)
    c = conn.cursor()

    c.execute("""
        SELECT u.id, u.username, u.email, u.role, u.created_at,
               COUNT(p.id) as prediction_count
        FROM users u
        LEFT JOIN predictions p ON u.id = p.user_id
        GROUP BY u.id
        ORDER BY u.created_at DESC
    """)

    users = [
        {
            "id": r[0],
            "username": r[1],
            "email": r[2],
            "role": r[3],
            "created_at": r[4],
            "prediction_count": r[5]
        }
        for r in c.fetchall()
    ]

    conn.close()
    return jsonify({"users": users})


@app.route("/admin/predictions", methods=["GET"])
@admin_required
def admin_predictions():
    conn = sqlite3.connect(DB_FILE)
    c = conn.cursor()

    c.execute("""
        SELECT p.id, u.username, p.prediction, p.confidence,
               p.is_tumor, p.created_at
        FROM predictions p
        JOIN users u ON p.user_id = u.id
        ORDER BY p.created_at DESC
        LIMIT 100
    """)

    predictions = [
        {
            "id": r[0],
            "username": r[1],
            "prediction": r[2],
            "confidence": round(r[3] * 100, 2),
            "is_tumor": bool(r[4]),
            "created_at": r[5]
        }
        for r in c.fetchall()
    ]

    conn.close()
    return jsonify({"predictions": predictions})


@app.route("/admin/users/<int:user_id>", methods=["DELETE"])
@admin_required
def delete_user(user_id):
    conn = sqlite3.connect(DB_FILE)
    c = conn.cursor()

    c.execute("DELETE FROM predictions WHERE user_id=?", (user_id,))
    c.execute("DELETE FROM users WHERE id=?", (user_id,))

    conn.commit()
    conn.close()
    return jsonify({"message": "User deleted"})


@app.route("/admin/users/<int:user_id>/role", methods=["PUT"])
@admin_required
def update_role(user_id):
    role = request.json.get("role")
    if role not in ["user", "superadmin"]:
        return jsonify({"error": "Invalid role"}), 400

    conn = sqlite3.connect(DB_FILE)
    c = conn.cursor()
    c.execute("UPDATE users SET role=? WHERE id=?", (role, user_id))
    conn.commit()
    conn.close()

    return jsonify({"message": "Role updated"})


# -----------------------------
# Run
# -----------------------------
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)